# --- unchanged header & imports ---
import json
import boto3
import os
import re
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Any, Optional, Tuple
from zoneinfo import ZoneInfo

def normalize_filter_pattern(pattern: Optional[str]) -> str:
    if not pattern:
        return ""
    p = str(pattern).strip()
    # 二重クォートなら外す
    if (p.startswith('"') and p.endswith('"')) or (p.startswith("'") and p.endswith("'")):
        inner = p[1:-1].strip()
        if (inner.startswith('"') and inner.endswith('"')) or (inner.startswith("'") and inner.endswith("'")):
            return inner[1:-1].strip()
    return p

def get_log_group_info_from_trigger(alarm_message: Dict[str, Any]) -> Dict[str, str]:
    """SNSアラームメッセージ内の Trigger から、logGroupName / filterPattern を特定する

    戻り値
    - { 'log_group_name': str, 'filter_pattern': str }

    例外
    - Trigger が無い、または一致するメトリクスフィルタが見つからない場合は ValueError
    """
    trigger = alarm_message.get("Trigger")
    if not trigger:
        raise ValueError("Trigger not found in alarm message")

    candidates: List[Tuple[str, str]] = []
    if isinstance(trigger, dict) and "MetricName" in trigger and "Namespace" in trigger:
        candidates.append((trigger.get("Namespace"), trigger.get("MetricName")))

    if not candidates:
        raise ValueError("No metric candidates found in Trigger")

    # 候補（Namespace, MetricName）で CloudWatch Logs のメトリクスフィルタを逆引き
    logs_client = boto3.client("logs")
    found_filters: List[Dict[str, Any]] = []
    for ns, mn in candidates:
        try:
            resp = logs_client.describe_metric_filters(metricName=mn, metricNamespace=ns)
            found_filters.extend(resp.get("metricFilters", []))
        except Exception as e:
            # 他の候補で継続
            print(f"describe_metric_filters error for {ns}/{mn}: {e}")

    if not found_filters:
        raise ValueError("No metric filters matched by Trigger's metrics")

    # 最初に一致したフィルタを採用
    chosen = found_filters[0]
    return {
        "log_group_name": chosen.get("logGroupName"),
        "filter_pattern": chosen.get("filterPattern", "")
    }

def extract_datapoint_timestamp_from_reason(state_reason: str) -> Optional[str]:
    """NewStateReason から評価データポイントの時刻を抽出（互換維持・今回フローでは未使用）"""
    if not state_reason:
        return None
    try:
        m = re.search(r"\((\d{2}/\d{2}/\d{2} \d{2}:\d{2}:\d{2})\)", state_reason)
        if not m:
            print(f"No timestamp pattern matched in: {state_reason}")
            return None
        ts = m.group(1)  # 例: "28/08/25 04:22:00"
        dd, mm, yy = ts.split(" ")[0].split("/")  # DD/MM/YY
        hhmmss = ts.split(" ")[1]
        full_year = f"20{yy}"
        corrected = f"{full_year}/{mm}/{dd} {hhmmss}"
        dt = datetime.strptime(corrected, "%Y/%m/%d %H:%M:%S")
        return dt.strftime("%Y-%m-%dT%H:%M:%S.000Z")
    except Exception as e:
        print(f"Error extracting timestamp from state reason: {e}")
        return None

# [ADDED] StateChangeTime 正規化ヘルパ
def parse_state_change_time_to_isoz(raw: str) -> str:
    """
    CloudWatch Alarm SNS の StateChangeTime 例:
      "2025-09-19T09:35:00.000+0000" や "2025-09-19T09:35:00+00:00"
    を UTC の ISO8601 Z 終端 "YYYY-MM-DDTHH:MM:SS.000Z" に正規化する。
    """
    if not raw:
        raise ValueError("StateChangeTime not found")
    s = raw.replace("Z", "+00:00")
    # +0000 / +0900 → +00:00 / +09:00
    s = re.sub(r"([+\-]\d{2})(\d{2})$", r"\1:\2", s)
    dt = datetime.fromisoformat(s)
    return dt.astimezone(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.000Z")

# [ADDED] バケット終端（StateChangeTime）ベースのログ抽出
def get_logs_from_bucket_end_window(
    log_group_name: str,
    filter_pattern: str,
    bucket_end_iso: str,
    period_seconds: int,
) -> List[Dict[str, Any]]:
    """
    CloudWatch の集計窓に一致させるため [bucket_end - Period, bucket_end] を検索する。
    返却は新しい順に最大10件。
    """
    logs_client = boto3.client("logs")
    try:
        end_dt = datetime.fromisoformat(bucket_end_iso.replace("Z", "+00:00"))
        start_dt = end_dt - timedelta(seconds=period_seconds)
        print(f"[CHANGED] Searching logs (bucket window) from {start_dt} to {end_dt} (period: {period_seconds}s)")

        search_pattern = normalize_filter_pattern(filter_pattern)
        resp = logs_client.filter_log_events(
            logGroupName=log_group_name,
            startTime=int(start_dt.timestamp() * 1000),
            endTime=int(end_dt.timestamp() * 1000),
            filterPattern=search_pattern,
            limit=20,
        )
        events = resp.get("events", [])
        events.sort(key=lambda x: x["timestamp"], reverse=True)
        return events[:10]
    except Exception as e:
        print(f"Error fetching logs (bucket window): {e}")
        return []

# --- unchanged generate_email_content (テキスト変更なし) ---
def generate_email_content(
    alarm_name: str,
    alarm_description: str,
    timestamp: str,
    reason: str,
    error_logs: List[Dict[str, Any]],
    log_group_name: str,
    search_method: str = "datapoint_period",
    old_state: Optional[str] = None,
    new_state: Optional[str] = None,
    alarm_arn: Optional[str] = None,
    datapoint_ts_iso: Optional[str] = None,
    period_seconds: Optional[int] = None,
) -> Tuple[str, str]:
    region_code = os.environ.get("AWS_REGION", "ap-northeast-1")
    region_long = {"ap-northeast-1": "Asia Pacific (Tokyo)"}.get(region_code, region_code)

    tzname = "Asia/Tokyo" if region_code == "ap-northeast-1" else "UTC"
    display_tz = ZoneInfo(tzname)

    try:
        sts = boto3.client("sts")
        account_id = sts.get_caller_identity().get("Account", "unknown")
    except Exception:
        account_id = "unknown"

    subject = f"ALARM: \"{alarm_name}\" in {region_long}"

    header = (
        f"You are receiving this email because your Amazon CloudWatch Alarm \"{alarm_name}\" "
        f"in the {region_long} region has entered the ALARM state, because \"{reason}\" "
        f"at \"{timestamp}\".\n\n"
    )

    details = (
        "Alarm Details:\n"
        f"- Name: {alarm_name}\n"
        f"- Description: {alarm_description}\n"
        f"- Timestamp: {timestamp}\n"
        f"- State Change: {old_state or 'UNKNOWN'} -> {new_state or 'UNKNOWN'}\n"
        f"- Reason for State Change: {reason}\n"
        f"- AWS Account: {account_id}\n"
        f"- Alarm Arn: {alarm_arn or 'unknown'}\n"
        f"- Region: {region_code}\n"
    )

    body_extra = "\n【検出されたログ】\n"
    if error_logs:
        # 表示レンジ: 呼び出し側から "ウィンドウ開始 = bucket_end - Period" を渡す
        if datapoint_ts_iso and period_seconds:
            start_dt_utc = datetime.fromisoformat(datapoint_ts_iso.replace("Z", "+00:00"))
            end_dt_utc   = start_dt_utc + timedelta(seconds=period_seconds)

            start_local = start_dt_utc.astimezone(display_tz)
            end_local   = end_dt_utc.astimezone(display_tz)

            window_start = start_local.strftime("%Y-%m-%d %H:%M")
            window_end   = end_local.strftime("%Y-%m-%d %H:%M")

            body_extra += (
                f"{window_start} ~ {window_end} の間に "
                f"{len(error_logs)} 件のエラーが検出されました:\n\n"
            )
        else:
            body_extra += f"直近のメトリクス期間に {len(error_logs)} 件のエラーが検出されました:\n\n"

        for ev in error_logs[:5]:
            message = ev.get("message", "")
            body_extra += message + "\n\n"

        if len(error_logs) > 5:
            body_extra += f"... 他 {len(error_logs) - 5} 件のエラーログがあります\n\n"
    else:
        body_extra += "詳細なエラーログの取得に失敗しました。\n\n"

    import urllib.parse
    encoded_alarm_name = urllib.parse.quote(alarm_name, safe="")
    region_code = os.environ.get("AWS_REGION", "ap-northeast-1")
    alarm_console_link = (
        "View this alarm in the AWS Management Console:\n"
        f"https://console.aws.amazon.com/cloudwatch/home?region={region_code}#alarmsV2:alarm/{encoded_alarm_name}\n\n"
    )

    try:
        cw = boto3.client("cloudwatch")
        resp = cw.describe_alarms(AlarmNames=[alarm_name])
        if resp.get("MetricAlarms"):
            al = resp["MetricAlarms"][0]
            comp = al.get("ComparisonOperator")
            thr = al.get("Threshold")
            evalp = al.get("EvaluationPeriods")
            d2a = al.get("DatapointsToAlarm")
            period = al.get("Period")
            n_dp = d2a if d2a is not None else evalp
            if comp and thr is not None and n_dp is not None and period is not None:
                sentence = (
                    f"- The alarm is in the ALARM state when the metric is {comp} {thr} "
                    f"for {n_dp} datapoints within {period} seconds.\n\n"
                )
            else:
                sentence = "- The alarm is in the ALARM state when the metric crosses the configured threshold.\n\n"
            threshold_block = "Threshold:\n" + sentence

            ns = al.get("Namespace")
            mn = al.get("MetricName")
            stat = al.get("Statistic") or al.get("ExtendedStatistic")
            unit = al.get("Unit")
            tmd = al.get("TreatMissingData")
            dims = al.get("Dimensions", [])
            dim_str = ", ".join([f"{d.get('Name')}={d.get('Value')}" for d in dims]) if dims else "None"
            mm_lines = [
                "Monitored Metric:",
                f"- MetricNamespace: {ns if ns is not None else 'None'}",
                f"- MetricName: {mn if mn is not None else 'None'}",
                f"- Dimensions: {dim_str}",
                f"- Period: {period} seconds" if period is not None else "- Period: None",
                f"- Statistic: {stat}" if stat else "- Statistic: None",
                f"- Unit: {unit if unit is not None else 'None'}",
                f"- TreatMissingData: {tmd if tmd is not None else 'None'}",
            ]
            monitored_metric_block = "\n".join(mm_lines) + "\n\n"

            def _fmt_actions(actions):
                return ", ".join(actions) if actions else "None"

            sca_lines = [
                "State Change Actions:",
                f"- OK: {_fmt_actions(al.get('OKActions'))}",
                f"- ALARM: {_fmt_actions(al.get('AlarmActions'))}",
                f"- INSUFFICIENT_DATA: {_fmt_actions(al.get('InsufficientDataActions'))}",
            ]
            state_change_actions_block = "\n".join(sca_lines) + "\n\n"
        else:
            threshold_block = "Threshold:\n- The alarm is in the ALARM state when the metric crosses the configured threshold.\n\n"
            monitored_metric_block = "Monitored Metric:\n- (not available)\n\n"
            state_change_actions_block = (
                "State Change Actions:\n- OK: None\n- ALARM: None\n- INSUFFICIENT_DATA: None\n\n"
            )
    except Exception:
        threshold_block = "Threshold:\n- The alarm is in the ALARM state when the metric crosses the configured threshold.\n\n"
        monitored_metric_block = "Monitored Metric:\n- (not available)\n\n"
        state_change_actions_block = (
            "State Change Actions:\n- OK: None\n- ALARM: None\n- INSUFFICIENT_DATA: None\n\n"
        )

    caution_block = (
        "【重要】購読解除に関する注意\n"
        "以下に記載されている Amazon SNS のリンクをクリックしないでください。\n"
        "クリックした場合、本アラートメールが届かなくなり運用に支障が出ます。\n"
    )

    body = header + body_extra + alarm_console_link + details + "\n" + threshold_block + monitored_metric_block + state_change_actions_block + caution_block
    return subject, body

def send_notification(sns_topic_arn: str, subject: str, body: str) -> None:
    """組み立てたメール本文を設定済み SNS トピックに Publish します。"""
    sns_client = boto3.client("sns")
    resp = sns_client.publish(TopicArn=sns_topic_arn, Subject=subject, Message=body)
    print(f"Notification sent successfully. MessageId: {resp['MessageId']}")

def process_alarm_event(alarm_data: Dict[str, Any]) -> None:
    """SNSメッセージから取り出した CloudWatch アラーム1件を処理します。

    手順
    1) 必須フィールドと ALARM 状態の検証
    2) Trigger から Logs:DescribeMetricFilters で logGroupName / filterPattern を解決
    3) [CHANGED] StateChangeTime（バケット終端）を取得・正規化
    4) [CHANGED] [end-Period, end] のウィンドウでログ抽出
    5) メール本文を組み立て、Publish
    """
    # 1) 出力先と入力の検証
    email_sns_topic_arn = os.environ.get("EMAIL_SNS_TOPIC_ARN")
    if not email_sns_topic_arn:
        raise ValueError("EMAIL_SNS_TOPIC_ARN environment variable not set")
    if "AlarmName" not in alarm_data:
        raise ValueError("Invalid alarm message: missing 'AlarmName'")

    alarm_name = alarm_data.get("AlarmName", "Unknown")
    alarm_description = alarm_data.get("AlarmDescription", "")
    new_state = alarm_data.get("NewStateValue", "UNKNOWN")
    reason = alarm_data.get("NewStateReason", "")
    timestamp = alarm_data.get("StateChangeTime", datetime.now().isoformat())
    old_state = alarm_data.get("OldStateValue", "UNKNOWN")
    alarm_arn = alarm_data.get("AlarmArn", "unknown")

    print(f"Processing alarm: {alarm_name}, State: {new_state}")
    if new_state != "ALARM":
        print("State is not ALARM. Skipping.")
        return

    # 2) Trigger からロググループとフィルターを解決
    info = get_log_group_info_from_trigger(alarm_data)
    log_group_name = info["log_group_name"]
    filter_pattern = normalize_filter_pattern(info.get("filter_pattern", ""))
    print(f"Resolved from Trigger - Log Group: {log_group_name}")
    print(f"Resolved from Trigger - Filter Pattern: {filter_pattern}")

    # 3) [CHANGED] StateChangeTime を正規化（バケット終端と見なす）
    try:
        bucket_end_iso = parse_state_change_time_to_isoz(timestamp)  # e.g., "2025-09-19T09:35:00.000Z"
    except Exception as e:
        raise ValueError(f"Failed to parse StateChangeTime: {e}")
    print(f"[CHANGED] Bucket end (StateChangeTime): {bucket_end_iso}")

    # 3.5) アラームの Period（秒）を取得（DescribeAlarms 優先、失敗時は Trigger/既定）
    try:
        cw = boto3.client("cloudwatch")
        _resp = cw.describe_alarms(AlarmNames=[alarm_name])
        _al = (_resp.get("MetricAlarms") or [None])[0]
        if _al and _al.get("Period") is not None:
            period_seconds = int(_al.get("Period"))
        else:
            period_seconds = int(alarm_data.get("Trigger", {}).get("Period") or 300)
    except Exception as e:
        print(f"Failed to get Period; fallback to Trigger/300. reason={e}")
        period_seconds = int(alarm_data.get("Trigger", {}).get("Period") or 300)

    # 4) [CHANGED] [bucket_end - Period, bucket_end] でログ抽出
    error_logs = get_logs_from_bucket_end_window(
        log_group_name, filter_pattern, bucket_end_iso, period_seconds
    )
    for i, log in enumerate(error_logs[:3]):
        print(f"Log {i+1}: {log.get('message', '')[:100]}...")

    # 5) メール本文を組み立てて送信
    #    generate_email_content は「datapoint_ts_iso をウィンドウ開始」と解釈するため、
    #    ここで (bucket_end - Period) を渡して表示レンジを正しく見せる。
    window_start_iso = datetime.fromisoformat(bucket_end_iso.replace("Z", "+00:00")) - timedelta(seconds=period_seconds)
    window_start_iso = window_start_iso.astimezone(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.000Z")  # start = end - Period

    subject, body = generate_email_content(
        alarm_name,
        alarm_description,
        timestamp,            # SNSのStateChangeTime（原文）をそのまま表示用に
        reason,
        error_logs,
        log_group_name,
        search_method="datapoint_period",  # 表示文面は維持（処理ロジックはStateChangeTime基準）
        old_state=old_state,
        new_state=new_state,
        alarm_arn=alarm_arn,
        datapoint_ts_iso=window_start_iso,  # [CHANGED] ウィンドウ開始を渡す
        period_seconds=period_seconds,
    )
    print(f"Email subject: {subject}")
    print(f"Email body preview: {body[:500]}...")

    send_notification(email_sns_topic_arn, subject, body)

def lambda_handler(event, context):
    """エントリポイント。SNSイベントのみ受け付けます。

    - 監視性のため、入力イベントの基本情報をログ出力
    - SNS Records を走査し、各メッセージに対して process_alarm_event() を呼び出し
    - SNS 以外のイベントは例外を送出
    """
    print("=== LAMBDA FUNCTION STARTED ===")
    print(f"Event type: {type(event)}")
    print(f"Event keys: {list(event.keys()) if isinstance(event, dict) else 'Not a dict'}")
    print("=== EVENT RECEIVED ===")
    print(json.dumps(event, indent=2, default=str))

    if not (isinstance(event, dict) and "Records" in event):
        print("Unsupported event: expected SNS Records. Aborting.")
        raise ValueError("Unsupported event source. This function must be invoked via SNS.")

    email_sns_topic_arn = os.environ.get("EMAIL_SNS_TOPIC_ARN")
    print(f"EMAIL_SNS_TOPIC_ARN: {email_sns_topic_arn}")
    if not email_sns_topic_arn:
        raise ValueError("EMAIL_SNS_TOPIC_ARN environment variable not set")

    for i, record in enumerate(event["Records"]):
        print(f"Record {i}: EventSource = {record.get('EventSource', 'Unknown')}")
        if record.get("EventSource") != "aws:sns":
            print(f"Unknown event source: {record.get('EventSource')}")
            continue
        msg = json.loads(record["Sns"]["Message"]) if isinstance(record.get("Sns", {}), dict) else {}
        process_alarm_event(msg)

    print("=== FUNCTION COMPLETED SUCCESSFULLY ===")
    return {"statusCode": 200, "body": json.dumps({"message": "Error notification processed successfully"})}
